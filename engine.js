(()=>{"use strict";class t{constructor(e){this.onDestroy=t=>{this._onDestroy=t},this.addTags=(...t)=>{t.forEach((t=>{this.compareTag(t)||this.Tags.push(t)}))},this.compareTag=t=>void 0!==this.Tags.find((e=>e===t)),this.destroy=()=>{t.destroy(this.Name),this._onDestroy&&this._onDestroy()},this.Name=e,this.Tags=[],t.add(this)}get Childs(){return Array.from(t.BaseObjects,(([t,e])=>e)).filter((t=>t.Parent===this))}set Name(e){if(t.find(e))throw new Error(`ОШИБКА: ${this.constructor.name} с именем '${e}' уже существует.`);this._Name=e}get Name(){return this._Name}static add(e){if(t.find(e.Name))throw new Error(`ОШИБКА: ${this.name} с именем '${e.Name}' уже существует.`);this.BaseObjects.set(e.Name,e)}static find(t){return this.BaseObjects.get(t)}static findByTag(t){return Array.from(this.BaseObjects,(([t,e])=>e)).filter((e=>this.name===e.constructor.name&&e.compareTag(t)))}static findAll(){return Array.from(this.BaseObjects,(([t,e])=>e)).filter((t=>this.name===t.constructor.name))}static destroy(t){this.BaseObjects.delete(t)}}t.BaseObjects=new Map;class e extends t{constructor(t,e){super(t),this.addObject=t=>{t.setLayer(this)},this.update=()=>{this.Childs.forEach((t=>{t.broadcast&&t.broadcast("update")}))},this.Parent=e,this.Context=e.Context}get Childs(){return super.Childs}get Scene(){return this.Parent}get Order(){return this._Order}set Order(t){this._Order=t,this.Parent.sortLayers()}}class s extends t{constructor(s,i){super(s),this.addLayer=t=>{const s=new e(t,this);return s.Order=this.Childs.length,s},this.sortLayers=()=>{t.BaseObjects=new Map(Array.from(t.BaseObjects,(([t,e])=>e)).sort(((t,s)=>t instanceof e&&s instanceof e?t.Order>s.Order?1:t.Order<s.Order?-1:0:0)).map((t=>[t.Name,t])))},this.update=()=>{this.Childs.forEach((t=>{t.update()}))},this.Parent=i,this.Context=i.Context,this._IsActive=!0}get Childs(){return super.Childs}get Screen(){return this.Parent}get IsActive(){return this._IsActive}set IsActive(t){this._IsActive=t}get Order(){return this._Order}set Order(t){this._Order=t,this.Parent.sortScenes()}}class i{constructor(t){this.rotateByPoint=t=>(this.RadianAngle=-Math.atan2(t.Y-this.Center.Y,t.X-this.Center.X),this.RadianAngle),this.rotateByDegree=t=>(this.RadianAngle=t*Math.PI/180,this.RadianAngle),this.rotateByRadian=t=>(this.RadianAngle=t,this.RadianAngle),this.setCenter=t=>{this.Center=t},this.RadianAngle=0,this.Center=t}get DegreeAngle(){return 180*this.RadianAngle/Math.PI}}class a{constructor(){this.Position={X:0,Y:0},this.Rotation=new i(this.Position),this.Scale=1}get Position(){return this._Position}set Position(t){var e;this._Position=t,null===(e=this.Rotation)||void 0===e||e.setCenter(this._Position)}}class r extends t{constructor(t,...e){super(t),this.addComponent=t=>{const e=new t(this);return this.Components.set(t.name,e),e},this.getComponent=t=>{const e=this.Components.get(t.name);if(void 0===e)throw new Error(`ОШИБКА: Компонент '${t.name}' не найден.`);return e},this.detachComponent=t=>{this.Components.delete(t.name)},this.broadcast=(t,...e)=>{Array.from(this.Components,(([t,e])=>e)).filter((e=>e[t]&&"function"==typeof e[t])).forEach((s=>{if(s[t].length!==e.length)throw new Error(`ОШИБКА: Метод '${t}' в компоненте '${s.constructor.name}' количество переданных аргументов (${e.length}) не соответствует ожидаемому (${s[t].length})`);try{s[t].apply(this,...e)}catch(i){throw new Error(`ОШИБКА: Компонент '${s.constructor.name}' не смог запустить метод '${t}' со следующими аргументами: ${e.map((t=>"number"==typeof t?t:`'${t}'`)).join(", ")}.\n${i.message}`)}}))},this.setLayer=t=>{this.Layer=t,this.Parent=t},this.Components=new Map,this.Tags=[],this.IsHidden=!1,this.Transform=new a,e.forEach((t=>{this.addComponent(t)}))}static find(t){return super.find(t)}static findAll(){return super.findAll()}static findByTag(t){return super.findByTag(t)}static findByComponent(t){return Array.from(super.BaseObjects,(([t,e])=>e)).filter((e=>e instanceof r&&e.getComponent(t)))}}class o{constructor(t){this.GameObject=t}}class n extends o{constructor(){super(...arguments),this._Dots=[],this.Opacity=1,this.drawByDots=(...t)=>{this._Radius=void 0,this._Dots=t,this._drawAction=()=>{if(this.GameObject.Layer&&!this.GameObject.IsHidden){this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity;const e=this.GameObject.Transform.Position.X,s=this.GameObject.Transform.Position.Y,i=this.GameObject.Transform.Rotation.RadianAngle;this._Dots.forEach(((a,r,o)=>{const n=a.X+e,h=a.Y+s,c=Math.cos(i),d=Math.sin(i);if(0===r?this.GameObject.Layer.Context.moveTo(c*(n-e)+d*(h-s)+e,c*(h-s)-d*(n-e)+s):this.GameObject.Layer.Context.lineTo(c*(n-e)+d*(h-s)+e,c*(h-s)-d*(n-e)+s),r===t.length-1){const t=o[0].X+e,i=o[0].Y+s;this.GameObject.Layer.Context.lineTo(c*(t-e)+d*(i-s)+e,c*(i-s)-d*(t-e)+s)}})),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()),this.BackgroundColor&&(this.GameObject.Layer.Context.fillStyle=this.BackgroundColor,this.GameObject.Layer.Context.fill()),this.GameObject.Layer.Context.closePath()}}},this.drawByDotsCount=(t,e)=>{const s=[];for(let i=0;i<t;i++){const a=360/t*(Math.PI/180)*i,r=this.GameObject.Transform.Position.X,o=this.GameObject.Transform.Position.Y,n=r+e,h=o,c=Math.cos(a),d=Math.sin(a);s.push({X:c*(n-r)+d*(h-o),Y:c*(h-o)-d*(n-r)})}this.drawByDots(...s)},this.setStroke=(t,e="black")=>{this.StrokeWidth=t,this.StrokeColor=e},this.setStrokeDash=t=>{this.StrokeDashTemplate=t},this.getStrokeWidth=()=>this.StrokeWidth,this.getStrokeColor=()=>this.StrokeColor,this.drawCircle=t=>{this._Radius=t,this._drawAction=()=>{if(this.GameObject.Layer&&!this.GameObject.IsHidden){this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity;const e=this.GameObject.Transform.Position.X,s=this.GameObject.Transform.Position.Y;this.GameObject.Layer.Context.arc(e,s,t,this.GameObject.Transform.Rotation.RadianAngle,2*Math.PI+this.GameObject.Transform.Rotation.RadianAngle),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()),this.BackgroundColor&&(this.GameObject.Layer.Context.fillStyle=this.BackgroundColor,this.GameObject.Layer.Context.fill()),this.GameObject.Layer.Context.closePath()}}},this.drawLineTo=t=>{this._Radius=void 0,this._Dots=[this.GameObject.Transform.Position,t],this._drawAction=()=>{this.GameObject.Layer&&!this.GameObject.IsHidden&&(this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity,this.GameObject.Layer.Context.moveTo(this.GameObject.Transform.Position.X,this.GameObject.Transform.Position.Y),this.GameObject.Layer.Context.lineTo(t.X,t.Y),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()))}},this.setBackground=t=>{this.BackgroundColor=t},this.getBackground=()=>this.BackgroundColor,this.setOpacity=(t=1)=>{this.Opacity=t},this.getOpacity=()=>this.Opacity,this.getDots=()=>this._Dots.map((t=>({X:t.X+this.GameObject.Transform.Position.X,Y:t.Y+this.GameObject.Transform.Position.Y}))),this.getRadius=()=>this._Radius,this.update=()=>{void 0!==this._drawAction&&this._drawAction()}}}var h;!function(t){t.White="#fff",t.Black="#000",t.Red="#f00",t.Green="#0f0",t.Blue="#00f"}(h||(h={}));class c{}c.Integer=(t=0,e=1)=>Math.floor(c.Float(t,e)),c.Float=(t=0,e=1)=>Math.random()*(e-t+1)+t,c.Color=()=>`rgb(${c.Integer(0,255)}, ${c.Integer(0,255)}, ${c.Integer(0,255)})`,c.Boolean=()=>1===c.Integer(0,1);const d=new class extends t{constructor(e,i,a){super("GameScreen"),this._resizeCanvas=()=>{this.Canvas.width=innerWidth,this.Canvas.height=innerHeight,this.Canvas.style.cssText="position: absolute; top: 0; left: 0;"},this.addScene=t=>{const e=new s(t,this);return e.Order=this.Childs.length,e},this.removeScene=t=>{var e;null===(e=s.find(t))||void 0===e||e.destroy()},this.update=()=>{this.Context.clearRect(0,0,this.Canvas.width,this.Canvas.height),this.Childs.filter((t=>t.IsActive)).forEach((t=>{t.update()}))},this.sortScenes=()=>{t.BaseObjects=new Map(Array.from(t.BaseObjects,(([t,e])=>e)).sort(((t,e)=>t instanceof s&&e instanceof s?t.Order>e.Order?1:t.Order<e.Order?-1:0:0)).map((t=>[t.Name,t])))},this.play=()=>{this.update(),this.Loop=requestAnimationFrame(this.play)},this.pause=()=>{cancelAnimationFrame(this.Loop)},this.Canvas=document.createElement("canvas"),this.Context=this.Canvas.getContext("2d"),void 0===i||void 0===a||null===i||null===a?(this._resizeCanvas(),window.addEventListener("resize",(t=>{this._resizeCanvas()}))):(this.Canvas.width=i,this.Canvas.height=a),e.appendChild(this.Canvas)}get Childs(){return super.Childs}}(document.body,800,800);d.Canvas.style.border="1px solid #000";const l=d.addScene("game").addLayer("world"),m=d.Canvas.width/40;(t=>{const e=[];for(let t=0;t<40;t++){e[t]=[];for(let s=0;s<40;s++)e[t].push(!0)}return e.forEach(((t,e,s)=>{if(0===e)t.forEach(((t,i)=>{s[e][i]=!1}));else{let t=0;do{s[e][t]=c.Boolean(),s[e][t]&&(s[e][c.Integer(0,t)]=!1,t=s.length),t++}while(t<s.length)}})),e})().forEach(((t,e)=>{t.forEach(((t,s)=>{if(t){const t=new r(`cube_${e}_${s}`,n);t.Transform.Rotation.rotateByDegree(45),t.Transform.Position={X:s*m+m/2,Y:e*m+m/2};const i=t.getComponent(n);i.drawByDotsCount(4,Math.sqrt(Math.pow(m/2,2)+Math.pow(m/2,2))),i.setBackground("red"),l.addObject(t)}}))})),d.play()})();