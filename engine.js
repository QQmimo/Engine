(()=>{"use strict";class t{constructor(e){this.onDestroy=t=>{this._onDestroy=t},this.addTags=(...t)=>{t.forEach((t=>{this.compareTag(t)||this.Tags.push(t)}))},this.compareTag=t=>void 0!==this.Tags.find((e=>e===t)),this.destroy=()=>{t.destroy(this.Name),this._onDestroy&&this._onDestroy()},this.Name=e,this.Tags=[],t.add(this)}get Childs(){return Array.from(t.BaseObjects,(([t,e])=>e)).filter((t=>t.Parent===this))}set Name(e){if(t.find(e))throw new Error(`ОШИБКА: ${this.constructor.name} с именем '${e}' уже существует.`);this._Name=e}get Name(){return this._Name}static add(e){if(t.find(e.Name))throw new Error(`ОШИБКА: ${this.name} с именем '${e.Name}' уже существует.`);this.BaseObjects.set(e.Name,e)}static find(t){return this.BaseObjects.get(t)}static findByTag(t){return Array.from(this.BaseObjects,(([t,e])=>e)).filter((e=>this.name===e.constructor.name&&e.compareTag(t)))}static findAll(){return Array.from(this.BaseObjects,(([t,e])=>e)).filter((t=>this.name===t.constructor.name))}static destroy(t){this.BaseObjects.delete(t)}}t.BaseObjects=new Map;class e extends t{constructor(t,e){super(t),this.addObject=t=>{t.setLayer(this)},this.update=()=>{this.Childs.forEach((t=>{t.broadcast&&t.broadcast("update")}))},this.Parent=e,this.Context=e.Context}get Childs(){return super.Childs}get Order(){return this._Order}set Order(t){this._Order=t,this.Parent.sortLayers()}}class s extends t{constructor(s,i){super(s),this.addLayer=t=>{const s=new e(t,this);return s.Order=this.Childs.length,s},this.sortLayers=()=>{t.BaseObjects=new Map(Array.from(t.BaseObjects,(([t,e])=>e)).sort(((t,s)=>t instanceof e&&s instanceof e?t.Order>s.Order?1:t.Order<s.Order?-1:0:0)).map((t=>[t.Name,t])))},this.update=()=>{this.Childs.forEach((t=>{t.update()}))},this.Parent=i,this.Context=i.Context,this._IsActive=!1}get IsActive(){return this._IsActive}set IsActive(t){this._IsActive=t}get Childs(){return super.Childs}get Order(){return this._Order}set Order(t){this._Order=t,this.Parent.sortScenes()}}class i{constructor(t){this.rotateByPoint=t=>(this.RadianAngle=-Math.atan2(t.Y-this.Center.Y,t.X-this.Center.X),this.RadianAngle),this.rotateByDegree=t=>(this.RadianAngle=t*Math.PI/180,this.RadianAngle),this.rotateByRadian=t=>(this.RadianAngle=t,this.RadianAngle),this.RadianAngle=0,this.Center=t}get DegreeAngle(){return 180*this.RadianAngle/Math.PI}}class o{constructor(){this.Position={X:0,Y:0},this.Rotation=new i(this.Position),this.Scale=1}get Position(){return this._Position}set Position(t){this._Position=t,this.Rotation=new i(this._Position)}}class r extends t{constructor(t,...e){super(t),this.addComponent=t=>{const e=new t(this);return this.Components.set(t.name,e),e},this.getComponent=t=>{const e=this.Components.get(t.name);if(void 0===e)throw new Error(`ОШИБКА: Компонент '${t.name}' не найден.`);return e},this.detachComponent=t=>{this.Components.delete(t.name)},this.broadcast=(t,...e)=>{Array.from(this.Components,(([t,e])=>e)).filter((e=>e[t]&&"function"==typeof e[t])).forEach((s=>{if(s[t].length!==e.length)throw new Error(`ОШИБКА: Метод '${t}' в компоненте '${s.constructor.name}' количество переданных аргументов (${e.length}) не соответствует ожидаемому (${s[t].length})`);try{s[t].apply(this,...e)}catch(i){throw new Error(`ОШИБКА: Компонент '${s.constructor.name}' не смог запустить метод '${t}' со следующими аргументами: ${e.map((t=>"number"==typeof t?t:`'${t}'`)).join(", ")}.\n${i.message}`)}}))},this.setLayer=t=>{this.Layer=t,this.Parent=t},this.Components=new Map,this.Tags=[],this.IsHidden=!1,this.Transform=new o,e.forEach((t=>{this.addComponent(t)}))}static find(t){return super.find(t)}static findAll(){return super.findAll()}static findByTag(t){return super.findByTag(t)}}class n{constructor(t){this.GameObject=t}}class a extends n{constructor(){super(...arguments),this._Dots=[],this.Opacity=1,this.drawByDots=(...t)=>{this._Dots=t,this._drawAction=()=>{if(this.GameObject.Layer&&!this.GameObject.IsHidden){this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity;const e=this.GameObject.Transform.Position.X,s=this.GameObject.Transform.Position.Y,i=this.GameObject.Transform.Rotation.RadianAngle;this._Dots.forEach(((o,r,n)=>{const a=o.X+e,h=o.Y+s,c=Math.cos(i),d=Math.sin(i);if(0===r?this.GameObject.Layer.Context.moveTo(c*(a-e)+d*(h-s)+e,c*(h-s)-d*(a-e)+s):this.GameObject.Layer.Context.lineTo(c*(a-e)+d*(h-s)+e,c*(h-s)-d*(a-e)+s),r===t.length-1){const t=n[0].X+e,i=n[0].Y+s;this.GameObject.Layer.Context.lineTo(c*(t-e)+d*(i-s)+e,c*(i-s)-d*(t-e)+s)}})),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()),this.BackgroundColor&&(this.GameObject.Layer.Context.fillStyle=this.BackgroundColor,this.GameObject.Layer.Context.fill()),this.GameObject.Layer.Context.closePath()}}},this.drawByDotsCount=(t,e)=>{this._Dots=[];for(let s=0;s<t;s++){const i=360/t*(Math.PI/180)*s,o=this.GameObject.Transform.Position.X,r=this.GameObject.Transform.Position.Y,n=o+e,a=r,h=Math.cos(i),c=Math.sin(i);this._Dots.push({X:h*(n-o)+c*(a-r),Y:h*(a-r)-c*(n-o)})}this.drawByDots(...this._Dots)},this.setStroke=(t,e="black")=>{this.StrokeWidth=t,this.StrokeColor=e},this.setStrokeDash=t=>{this.StrokeDashTemplate=t},this.getStrokeWidth=()=>this.StrokeWidth,this.getStrokeColor=()=>this.StrokeColor,this.drawCircle=t=>{this._drawAction=()=>{if(this.GameObject.Layer&&!this.GameObject.IsHidden){this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity;const e=this.GameObject.Transform.Position.X,s=this.GameObject.Transform.Position.Y;this.GameObject.Layer.Context.arc(e,s,t,this.GameObject.Transform.Rotation.RadianAngle,2*Math.PI),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()),this.BackgroundColor&&(this.GameObject.Layer.Context.fillStyle=this.BackgroundColor,this.GameObject.Layer.Context.fill()),this.GameObject.Layer.Context.closePath()}}},this.drawLineTo=t=>{this._drawAction=()=>{this.GameObject.Layer&&!this.GameObject.IsHidden&&(this.GameObject.Layer.Context.beginPath(),this.GameObject.Layer.Context.globalAlpha=this.Opacity,this.GameObject.Layer.Context.moveTo(this.GameObject.Transform.Position.X,this.GameObject.Transform.Position.Y),this.GameObject.Layer.Context.lineTo(t.X,t.Y),this.StrokeColor&&(this.GameObject.Layer.Context.setLineDash(this.StrokeDashTemplate||[]),this.GameObject.Layer.Context.strokeStyle=this.StrokeColor,this.GameObject.Layer.Context.lineWidth=this.StrokeWidth,this.GameObject.Layer.Context.stroke()))}},this.setBackground=t=>{this.BackgroundColor=t},this.getBackground=()=>this.BackgroundColor,this.setOpacity=(t=1)=>{this.Opacity=t},this.getOpacity=()=>this.Opacity,this.update=()=>{void 0!==this._drawAction&&this._drawAction()}}}class h extends n{constructor(){super(...arguments),this._IsMoving=!1,this.Speed=1,this.Angle=0,this.moveTo=t=>{this.Target=t},this.onMove=t=>{this._onMove=t},this.onFinish=t=>{this._onFinish=t},this.onStart=t=>{this._onStart=t},this._move=()=>{if(void 0!==this.Target&&this.Target.X!==this.GameObject.Transform.Position.X&&this.Target.Y!==this.GameObject.Transform.Position.Y){this.Angle=Math.atan2(this.Target.Y-this.GameObject.Transform.Position.Y,this.Target.X-this.GameObject.Transform.Position.X),this._onStart&&!1===this._IsMoving&&this._onStart(this,this.GameObject,this.Target),this._IsMoving=!0;const t=Math.cos(this.Angle)*this.Speed,e=Math.sin(this.Angle)*this.Speed;this.GameObject.Transform.Position.X+=t,this.GameObject.Transform.Position.Y+=e,Math.abs(this.GameObject.Transform.Position.X-this.Target.X)<t&&(this.GameObject.Transform.Position.X=this.Target.X),Math.abs(this.GameObject.Transform.Position.Y-this.Target.Y)<e&&(this.GameObject.Transform.Position.Y=this.Target.Y),this._onMove&&this._onMove(this,this.GameObject,this.Target)}else void 0!==this.Target&&this._onFinish&&(this.Target=void 0,this._IsMoving=!1,this._onFinish(this,this.GameObject))},this.update=()=>{this._move()}}}class c extends n{constructor(){super(...arguments),this.List=new Map,this.set=(t,e)=>{this.List.set(t,e)},this.get=t=>this.List.get(t),this.delete=t=>{this.List.delete(t)}}}var d;!function(t){t.White="#fff",t.Black="#000",t.Red="#f00",t.Green="#0f0",t.Blue="#00f"}(d||(d={}));class m{}m.Integer=(t=0,e=1)=>Math.floor(m.Float(t,e)),m.Float=(t=0,e=1)=>Math.random()*(e-t)+t,m.Color=()=>`rgb(${m.Integer(0,255)}, ${m.Integer(0,255)}, ${m.Integer(0,255)})`;class l{}l.solve=(t,e={X:0,Y:0})=>Math.sqrt(Math.pow(e.X-t.X,2)+Math.pow(e.Y-t.Y,2));const g=new class extends t{constructor(e,i,o){super("GameScreen"),this._resizeCanvas=()=>{this.Canvas.width=innerWidth,this.Canvas.height=innerHeight,this.Canvas.style.cssText="position: absolute; top: 0; left: 0;"},this.addScene=t=>{const e=new s(t,this);return e.Order=this.Childs.length,e},this.removeScene=t=>{var e;null===(e=s.find(t))||void 0===e||e.destroy()},this.update=()=>{this.Context.clearRect(0,0,this.Canvas.width,this.Canvas.height),this.Childs.filter((t=>t.IsActive)).forEach((t=>{this.Context.setTransform(1,0,0,1,0,0),t.update(),this.Context.restore()}))},this.sortScenes=()=>{t.BaseObjects=new Map(Array.from(t.BaseObjects,(([t,e])=>e)).sort(((t,e)=>t instanceof s&&e instanceof s?t.Order>e.Order?1:t.Order<e.Order?-1:0:0)).map((t=>[t.Name,t])))},this.play=()=>{this.update(),this.Loop=requestAnimationFrame(this.play)},this.pause=()=>{cancelAnimationFrame(this.Loop)},this.Canvas=document.createElement("canvas"),this.Context=this.Canvas.getContext("2d"),void 0===i||void 0===o||null===i||null===o?(this._resizeCanvas(),window.addEventListener("resize",(t=>{this._resizeCanvas()}))):(this.Canvas.width=i,this.Canvas.height=o),e.appendChild(this.Canvas)}get Childs(){return super.Childs}}(document.body),C=g.addScene("game");C.IsActive=!0;const O=C.addLayer("hud"),f=C.addLayer("world"),u=g.addScene("menu"),y=u.addLayer("manu-layer");for(let t=0;t<500;t++){const e=new r(`cube_${t}`,a,h,c);e.Transform.Position={X:m.Integer(innerWidth),Y:m.Integer(innerHeight)};const s=e.getComponent(h);s.Speed=m.Integer(1,5),s.onStart(((t,e,s)=>{e.Transform.Rotation.rotateByPoint(s);const i=e.getComponent(a);i.drawByDotsCount(m.Integer(3,10),m.Integer(10,30)),i.setBackground(m.Color()),i.setStroke(1);const o=new r(`dot_${e.Name}`,a);o.Transform.Position=s;const n=o.getComponent(a);n.drawCircle(2),n.setBackground("red"),O.addObject(o),e.getComponent(c).set("distance",l.solve(e.Transform.Position,s));const h=new r(`line_${e.Name}`,a);h.Transform.Position=e.Transform.Position;const d=h.getComponent(a);d.setStrokeDash([5,3]),d.setOpacity(.35),d.setStroke(1),d.drawLineTo(s),O.addObject(h)})),s.onFinish(((t,e)=>{var s,i;null===(s=r.find(`dot_${e.Name}`))||void 0===s||s.destroy(),null===(i=r.find(`line_${e.Name}`))||void 0===i||i.destroy(),t.Speed=m.Integer(1,5),t.moveTo({X:m.Integer(innerWidth),Y:m.Integer(innerHeight)})})),s.onMove(((t,e,s)=>{const i=e.getComponent(c).get("distance"),o=Math.floor(255*l.solve(e.Transform.Position,s)/i);e.getComponent(a).setBackground(`rgb(${o}, ${255-o}, 0)`),r.find(`line_${e.Name}`).Transform.Position=e.Transform.Position})),s.moveTo({X:m.Integer(innerWidth),Y:m.Integer(innerHeight)}),f.addObject(e)}for(let t=0;t<10;t++){const e=new r(`Qube_${t}`,a);e.Transform.Position={X:m.Integer(innerWidth),Y:m.Integer(innerHeight)};const s=e.getComponent(a);s.drawCircle(m.Integer(10,30)),s.setBackground(m.Color()),y.addObject(e)}g.play(),g.Canvas.addEventListener("click",(()=>{O.Order>f.Order?(O.Order=1,f.Order=2):(O.Order=2,f.Order=1)}));let b=!1;g.Canvas.addEventListener("contextmenu",(t=>{b?(b=!1,g.play()):(b=!0,g.pause()),t.preventDefault()})),document.addEventListener("keypress",(t=>{"Spacebar"!==t.key&&" "!==t.key||!C.IsActive?(C.IsActive=!0,u.IsActive=!1):(C.IsActive=!1,u.IsActive=!0)}))})();